stages:
  - prepare-cloud-config
  - plan
  - apply
  - cleanup

# Генерация кастомного Cloud-Init конфигурационного файла
prepare-cloud-config:
  stage: prepare-cloud-config
  script:
    - echo "Генерация кастомного cloud-config"
    - export CUSTOM_CLOUD_CONFIG=$(cat <<EOF
#cloud-config
preserve_hostname: true
timezone: Europe/Moscow
package_update: true
package_upgrade: true
package_reboot_if_required: true
packages:
  - git
  - python3-pip
  - python3
  - ansible
users:
  - name: ubuntu
    groups: sudo
    shell: /bin/bash
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    lock_passwd: false
EOF
    )
    # Передаём cloud-config в качестве переменной Terraform
    - export TF_VAR_cloud_config="$CUSTOM_CLOUD_CONFIG"
    - echo "$CUSTOM_CLOUD_CONFIG" > cloud-config-preview.yml

    # Инициализация Terraform с конфигурацией для использования backend
    - export GITLAB_ACCESS_TOKEN=<YOUR-ACCESS-TOKEN>
    - terraform init \
        -backend-config="address=https://gitlab.exportcenter.ru/api/v4/projects/651/terraform/state/Env_Bastion_Dev_tfstate" \
        -backend-config="lock_address=https://gitlab.exportcenter.ru/api/v4/projects/651/terraform/state/Env_Bastion_Dev_tfstate/lock" \
        -backend-config="unlock_address=https://gitlab.exportcenter.ru/api/v4/projects/651/terraform/state/Env_Bastion_Dev_tfstate/lock" \
        -backend-config="username=mrudneva" \
        -backend-config="password=$GITLAB_ACCESS_TOKEN" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="retry_wait_min=5"
        
  artifacts:
    paths:
      - cloud-config-preview.yml  # Для отладки сохраняем сгенерированный файл

# Проверка изменений с учетом условий
plan:
  stage: plan
  script:
    - echo "Планирование изменений Terraform..."
    # Выполняем terraform plan с передачей кастомного cloud-config
    - terraform plan -var="cloud_config=$TF_VAR_cloud_config" -out=tfplan > plan_output.log

    # Анализируем план для проверки количества изменений и наличия удалений
    - export DESTROY_COUNT=$(grep -c "Destroying" plan_output.log)
    - export ADD_OR_CHANGE_COUNT=$(grep -E "Plan: [0-9]+ to add|change" plan_output.log | awk '{print $2}')
    - echo "Ресурсов на удаление: $DESTROY_COUNT"
    - echo "Ресурсов на добавление/изменение: $ADD_OR_CHANGE_COUNT"

    # Условие: отменяем, если есть удаления или слишком много изменений
    - if [[ "$DESTROY_COUNT" -gt 0 ]]; then echo "Ошибка: план включает удаление ресурсов. Требуется подтверждение!"; exit 1; fi
    - if [[ "$ADD_OR_CHANGE_COUNT" -gt 4 ]]; then echo "Ошибка: слишком много ресурсов изменяется. Требуется подтверждение!"; exit 1; fi

  artifacts:
    paths:
      - tfplan       # Сохраняем план для использования в следующем этапе
      - plan_output.log  # Лог плана для отладки
  when: manual  # Требует ручного подтверждения
  allow_failure: false
  
# Применение изменений, если они были одобрены
apply:
  stage: apply
  script:
    - echo "Применение изменений Terraform..."
    - terraform apply -auto-approve tfplan
  when: manual  # Ручное подтверждение, если план прошел !!!!!!!

# Очистка артефактов после выполнения этапов
cleanup:
  stage: cleanup
  script:
    - echo "Очистка артефактов..."
    - rm -f tfplan cloud-config-preview.yml plan_output.log
  when: always  # Этот этап всегда выполняется, даже если план или apply завершаются с ошибкой
  allow_failure: true  # Этот этап не влияет на пайплайн, если возникнут ошибки во время очистки




